package com.Engine {		import AbtinPat.Player;	import AbtinPat.Laser;	import AbtinPat.Item;	import AbtinPat.GameHUD;	import AbtinPat.Background	import AbtinPat.Turret;	import AbtinPat.FlyingEnemy;	import AbtinPat.CrossHair;	import AbtinPat.Missile;	import AbtinPat.Laser;	import AbtinPat.AsteroidGroup;	import AbtinPat.AsteroidSingle;	import com.greensock.loading.core.DisplayObjectLoader;	import flash.display.DisplayObject;	import flash.display.MovieClip;	import flash.display.SimpleButton;	import flash.display.Sprite;	import flash.display.BitmapData;	import flash.events.Event;	import flash.events.EventDispatcher;	import flash.events.IOErrorEvent;	import flash.events.KeyboardEvent;	import flash.events.MouseEvent;	import flash.ui.Mouse;	import flash.events.Event;	import flash.events.ProgressEvent;	import flash.events.TimerEvent;	import flash.geom.Point;	import flash.geom.Rectangle;	import flash.geom.Vector3D;	import flash.net.*;	import flash.utils.getTimer;	import flash.utils.Timer;	import flash.media.SoundTransform;		import com.Engine.events.APEvent;	import com.Engine.Sprites.*;	import com.Engine.Sound.SoundEngine;	import com.Engine.Level.LevelManager;	import com.Engine.HID.HIDManager;	import com.Engine.Core.Clock;	import com.greensock.*;	import com.greensock.easing.*; 	import com.greensock.plugins.*;	TweenPlugin.activate([BlurFilterPlugin]);		import flash.net.SharedObject;		public class APEngine extends Sprite {				public static const DEFAULT_FRAME_RATE:int = 60;		public const SCREEN_WIDTH:int = 854; 		public const SCREEN_HEIGHT:int = 480; 				protected var _gravity:Vector3D;		protected var _friction:Number;		protected var _config:APConfig;		protected var _currentLevel:int;				protected var _items:Array;		//protected var _enemies:Array;		protected var _playerProjectileList:Vector.<IProjectile>;		protected var _playerProjectileSpeed:Number = 20;		protected var _enemyList:Vector.<IEnemy>;		protected var _enemyProjectileList:Vector.<IProjectile>;		protected var _enemyProjectileSpeed:Number = 20;		protected var _asteroidList:Vector.<IAsteroid>;		protected var _asteroidSpeed:Number = 1;		protected var _levels:Vector.<DisplayObject>;		protected var _player:IPlayer;		protected var _crossHair:CrossHair;		protected var _gameHUD:GameHUD;		protected var _background:Background;		protected var _gameRunning:Boolean = false;		private var _score:Number = 0;		protected var _inventory:Vector.<IItem>;		protected var se:SoundEngine;		protected var lm:LevelManager;		protected var hm:HIDManager;		protected var gameClock:Clock;		protected var playerLastShotTime:int = 0;		protected var playerShotDelayTime:int = 1000;		protected var enemyShotDelayTime:int = 2000;		protected var switchWeaponLastTime:int = 0;		protected var switchWeaponDelayTime:int = 250;		protected var lastOrbSpawnTime:int = 0;		protected var orbDelayTime:int = 10000;		protected var numOrbsToSpawn:int = 5;		protected var playerMovementPlane:int = 1;		protected var switchingPlane:Boolean = false;		protected var switchingWeapon:Boolean = false;		protected var switchingPlayerState:Boolean = false;		protected var borderBoundaryDistance:int = 80; 		protected var numRedOrbs:int = 0;		protected var numBlueOrbs:int = 0;		protected var numGreenOrbs:int = 0;		protected var numYellowOrbs:int = 100;		protected var currentWeapon = 1;		protected var levelNameClicked:String;		protected var crossHairType:int = 1;		protected var crossHairLock:Boolean = false;		protected var crossHairLastDirection:int = 1;		protected var switchCrossHairLastTime:int = 0;		protected var switchCrossHairDelayTime:int = 250;		protected var projectileLifeTime:int = 2000;		protected var _layerList:Vector.<DisplayObject>;		protected var _levelBytesLoaded:int = 0;		protected var _soundBytesLoaded:int = 0;		protected var _currentMusic:String;		protected var _crossHairScale:Number = 1.0;		protected var _levelCleared:Boolean = false;								public function APEngine() {			se = SoundEngine.getInstance();			lm = LevelManager.getInstance();			hm = HIDManager.getInstance();			hm.setHIDMouseKeyboard();			addChild(hm);			gameClock = Clock.getInstance();			_playerProjectileList = new Vector.<IProjectile>();			_enemyProjectileList = new Vector.<IProjectile>();			_enemyList = new Vector.<IEnemy>();			_asteroidList = new Vector.<IAsteroid>();			_items = new Array();			_levels = new Vector.<DisplayObject>();			_levelBytesLoaded = 0;			_soundBytesLoaded = 0;		}				public function init(config:APConfig):void {			_config = config;			numRedOrbs = _config.numRedOrbs;			numBlueOrbs = _config.numBlueOrbs;			numYellowOrbs = _config.numYellowOrbs;			numGreenOrbs = _config.numGreenOrbs;			_score = _config.score;						_gravity = _config.gravity;			_friction = _config.friction;			_inventory = new Vector.<IItem>();		}					public function startGame():void {			if (!stage) throw new Error("APEngine instance must be added to stage before startGame() is called.");						_gameRunning = true;			gameClock.resetTime();			addEventListener(Event.ENTER_FRAME, gameLoop, false, 0, true);			if (_currentLevel == 0)				addLevelEventListeners();			hm.addHIDManagerListeners();			if ( !se.isPlaying(_currentMusic) ) {				se.playSound(_currentMusic, 0, -1);			}			else {				se.pause(_currentMusic);			}			//.addEventListener(PlatformerEvent.INVENTORY_UPDATE, inventoryUpdate, false, 0, true);			Mouse.hide();		}				public function stopGame():void {			if (!stage) throw new Error("APEngine instance must be added to stage before stopGame() is called.");			hm.removeHIDManagerListeners();			removeEventListener(Event.ENTER_FRAME, gameLoop);			if (_currentLevel == 0)				removeLevelEventListeners();			_gameRunning = false;						se.pause(_currentMusic);			Mouse.show();		}				/*public function get inventory():Vector.<IItem> {			return _inventory.slice();		}*/					/*public function get inventoryWorth():Number {			var worth:Number = 0;			for each (var item:IItem in _inventory) {				worth += item.points;			}			return worth;		}*/					public function destroy():void {			_config.numBlueOrbs = numBlueOrbs;			_config.numRedOrbs = numRedOrbs;			_config.numGreenOrbs = numGreenOrbs;			_config.numYellowOrbs = numYellowOrbs;			_config.score = _score; 			_config.playerState = _player.playerState;			_config.saveUserInfo();						clearReferences();			for (var i:int = numChildren - 1; i >= 0; i--) {				removeChildAt(i);			}		}				protected function clearReferences():void {			//_inventory = null;			//_items = null;			//_enemies = null;			_levels = null;			_player = null;			_items = null;			_playerProjectileList = null; 			_enemyProjectileList = null;			_enemyList = null;			_gameHUD = null;			lm.unloadLevel();			se.unloadSounds();		}				public function startLevel(levelNum:int) {			_currentLevel = levelNum;						lm.addEventListener(ProgressEvent.PROGRESS, levelLoadProgress, false, 0, true);			lm.addEventListener(APEvent.LEVEL_LOAD_COMPLETE, levelLoadComplete, false, 0, true);			switch(levelNum) {				case 0:					lm.loadLevel("Assets/Levels/world.xml");					break;				case 1:					lm.loadLevel("Assets/Levels/outsideCloudsLevel.xml");					break;				case 2:					lm.loadLevel("Assets/Levels/insideCloudsLevel.xml");					break;				case 3:					lm.loadLevel("Assets/Levels/homeLevel.xml");					break;				default:					break;			}		}				protected function levelLoadProgress(e:ProgressEvent) {			_levelBytesLoaded = e.bytesLoaded;			dispatchEvent(new ProgressEvent(ProgressEvent.PROGRESS, false, false, _levelBytesLoaded+_soundBytesLoaded, 200));		}				protected function levelLoadComplete(e:APEvent) {			lm.removeEventListener(APEvent.LEVEL_LOAD_COMPLETE, levelLoadComplete);			lm.removeEventListener(ProgressEvent.PROGRESS, levelLoadProgress);						se.loadSounds("Assets/Sounds/sounds.xml");			se.addEventListener(APEvent.SOUNDS_LOAD_COMPLETE, soundLoadComplete, false, 0, true);			se.addEventListener(ProgressEvent.PROGRESS, soundLoadProgress, false, 0, true);		}		protected function soundLoadProgress(e:ProgressEvent) {			_soundBytesLoaded = e.bytesLoaded;			dispatchEvent(new ProgressEvent(ProgressEvent.PROGRESS, false, false, _levelBytesLoaded+_soundBytesLoaded, 200));		}				protected function soundLoadComplete(e:APEvent) {			se.removeEventListener(APEvent.SOUNDS_LOAD_COMPLETE, soundLoadComplete);			se.removeEventListener(ProgressEvent.PROGRESS, soundLoadProgress);			setGameObjectReferences();		}						protected function setGameObjectReferences():void {  						switch (_currentLevel) {				case 0:					_background = new lm.backgroundClass();					_background.setupBackground(SCREEN_WIDTH, SCREEN_HEIGHT);					_background.setOuterWorldLevelReferences();										//_levels.push(_background.getMoons());					_levels.push(_background.getOutsideClouds());					//_levels.push(_background.getRings());					//_levels.push(_background.getAsteroidFloater());					//_levels.push(_background.getAsteroidCluster());					_levels.push(_background.getInsideClouds());					_levels.push(_background.getHome());					addChild(_background);					_currentMusic = "outerSpaceMusic";					break;				case 1:					_background = new lm.backgroundClass();					_background.setupBackground(SCREEN_WIDTH, SCREEN_HEIGHT);					addChild(_background);					_currentMusic = "homeLevelMusic";					break;				case 2:					_background = new lm.backgroundClass();					_background.setupBackground(SCREEN_WIDTH, SCREEN_HEIGHT);					addChild(_background);					_currentMusic = "insideCloudsLevelMusic";					break;				case 3:					_background = new lm.backgroundClass();					_background.setupBackground(SCREEN_WIDTH, SCREEN_HEIGHT);					addChild(_background);					_currentMusic = "outsideCloudsLevelMusic";					break;			}						_layerList = _background.layerList;						_crossHair = new lm.crossHair1Class();			_crossHair.x = mouseX;			_crossHair.y = mouseY;			_crossHair.tempX = _crossHair.x;			_crossHair.tempY = _crossHair.y;			addChild(_crossHair as DisplayObject);						_gameHUD = lm.gameHUD; 			_gameHUD.initializeGameHUD();			addChild(_gameHUD as DisplayObject);						_enemyList = lm.enemyList;			for each ( var enemy:IEnemy in _enemyList) {				//if ( enemy is Turret) {					//(_layerList[0] as MovieClip).addChild(enemy as DisplayObject);				//}				//else {					(_layerList[1] as MovieClip).addChild(enemy as DisplayObject);				//}			}						_player = lm.player;			_player.x = _player.tempX = _background.globalToLocal(new Point(_player.x, _player.y)).x;			_player.y = _player.tempY = _background.globalToLocal(new Point(_player.x, _player.y)).y;			_player.angle = 0;			_player.rotation = _player.tempRotation;			_player.acceleration = new Vector3D();			_player.velocity = new Vector3D();			_player.playerState = _config.playerState;			_player.shieldHealth = numYellowOrbs;			_player.health = numBlueOrbs;			(_layerList[1] as MovieClip).addChildAt(_player as DisplayObject,(_layerList[1] as MovieClip).numChildren);			changePlayerState();						/*			for each (var turret:IEnemy in _turretList) {				var myPoint = new Point(turret.x,turret.y);				trace(_background.localToGlobal(500,500));			}			*/			/*			_items = lm.items;			for each (var itemSprite:IItem in _items) {				_background.addChild(itemSprite as DisplayObject);			}			*/			dispatchEvent(new APEvent(APEvent.LEVEL_LOAD_COMPLETE));		}				protected function addLevelEventListeners():void {			for each (var level:DisplayObject in _levels) {				level.addEventListener(MouseEvent.MOUSE_OVER, levelOver, false, 0, true);				level.addEventListener(MouseEvent.MOUSE_DOWN, levelDown, false, 0, true);				level.addEventListener(MouseEvent.MOUSE_OUT, levelOut, false, 0, true);			}		}				protected function removeLevelEventListeners():void {			for each (var level:DisplayObject in _levels) {				level.removeEventListener(MouseEvent.MOUSE_OVER, levelOver);				level.removeEventListener(MouseEvent.MOUSE_DOWN, levelDown);				level.removeEventListener(MouseEvent.MOUSE_OUT, levelOut);			}		}				protected function levelOver(e:MouseEvent) {			TweenLite.to(e.target as DisplayObject, 1, { scaleX:1.25, scaleY:1.25} );		}		protected function levelDown(e:MouseEvent) {			levelNameClicked = e.target.name;			dispatchEvent(new APEvent(APEvent.SHOW_ENTER_LEVEL));			trace(levelNameClicked );		}		protected function levelOut(e:MouseEvent) {			TweenLite.to(e.target as DisplayObject, 1, { scaleX:1.0, scaleY:1.0} );		}				public function getLevelNameClicked():String {			return levelNameClicked;		}				//BEGIN GAME LOOP LOGIC		protected function gameLoop(e:Event):void {			if(_gameRunning)				gameClock.updateTime();						readKeyInput();			checkCrossHair();			applyForces();			movePlayer();			movePlayerProjectiles();			moveEnemies();			moveEnemyProjectiles();			checkPlayerCollisions();			checkEnemyCollisions();			checkItems();			if (_currentLevel == 0) {				createAsteroids();				moveAsteroids();				checkAsteroidCollisions();			}			updateGameHUD();			scrollBackground();			render();		}				protected function updateGameHUD():void {			_gameHUD.updateTimeElapsed(gameClock.timeElapsed);			_gameHUD.updatePointsText(_score.toString());			_gameHUD.adjustRedBar(numRedOrbs);			_gameHUD.adjustBlueBar(numBlueOrbs);			_gameHUD.adjustGreenBar(numGreenOrbs);			_gameHUD.adjustYellowBar(numYellowOrbs);		}				protected function readKeyInput():void {			_player.acceleration = new Vector3D();			if (hm.mouse.mousePressed) {				//var mousePoint:Point = localToGlobal(new Point(mouseX, mouseY));				//_player.angle = Math.atan2(mousePoint.y - tempY, mousePoint.x - tempX);				//_player.angle = Math.atan2(mouseY - _player.tempY, mouseX - _player.tempX);								if ( _player.directionToTurn == 1){					_player.angle += (_player.maxSteering * (_player.velocity.length / _player.maxSpeed));				}				else if ( _player.directionToTurn == -1 ){					_player.angle -= (_player.maxSteering * (_player.velocity.length / _player.maxSpeed));				}								_player.acceleration.x += Math.cos(_player.angle-Math.PI/2) * _player.maxAcceleration * gameClock.deltaTime;				_player.acceleration.y += Math.sin(_player.angle-Math.PI/2) * _player.maxAcceleration * gameClock.deltaTime;			}			else if (!hm.mouse.mousePressed) {				_player.acceleration.x = Math.cos(_player.angle-Math.PI/2) * _player.minAcceleration * gameClock.deltaTime;				_player.acceleration.y = Math.sin(_player.angle-Math.PI/2) * _player.minAcceleration * gameClock.deltaTime;				}									if (hm.keyboard.switchPlanePressed && (_player.health > 0 || _player.shieldHealth > 0) && !switchingPlane && !switchingPlayerState) {				var testPlayer:Rectangle = _player.getRect(this as DisplayObject);				var i:int ;				var testObject:Rectangle;				for (i = 1; i < (_layerList[0] as MovieClip).numChildren; i++) {					if ((_layerList[0] as MovieClip).getChildAt(i) == _player || ((_layerList[0] as MovieClip).getChildAt(i) is IProjectile) ) {						continue;					}					testObject = (_layerList[0] as MovieClip).getChildAt(i).getRect(this as DisplayObject);					if (testPlayer.intersects(testObject)) {						return;					}				}				for (i = 1; i < (_layerList[1] as MovieClip).numChildren; i++) {					if ((_layerList[1] as MovieClip).getChildAt(i) == _player  || ((_layerList[1] as MovieClip).getChildAt(i) is IProjectile) ) {						continue;					}					testObject = (_layerList[1] as MovieClip).getChildAt(i).getRect(this as DisplayObject);					if (testPlayer.intersects(testObject)) {						return;					}				}								switchingPlane = true;				switch(playerMovementPlane) {					case 1:						TweenLite.to(_player as DisplayObject, 0.5, { scaleX:0.66, scaleY:0.66, onComplete:moveDownLevel } );						TweenLite.to(_crossHair as DisplayObject, 0.5, { scaleX:0.66, scaleY:0.66 } );						_crossHairScale = .66;						se.playSound("movePlaneDownLevelSound");						break;					case -1:						TweenLite.to(_player as DisplayObject, 0.5, { scaleX:1.5, scaleY:1.5, onComplete:moveUpLevel } );						TweenLite.to(_crossHair as DisplayObject, 0.5, { scaleX:1.0, scaleY:1.0 } );						_crossHairScale = 1.0;						se.playSound("movePlaneUpLevelSound");						break;				}			}						/*			_player.acceleration = new Vector3D();			if (hm.keyboard.upPressed) {				_player.acceleration.x += Math.cos(_player.angle) * Player.maxAcceleration * gameClock.deltaTime;				_player.acceleration.y += Math.sin(_player.angle) * Player.maxAcceleration * gameClock.deltaTime;			}			if (hm.keyboard.downPressed) {				_player.acceleration.x += -Math.cos(_player.angle) * Player.maxAcceleration * gameClock.deltaTime;				_player.acceleration.y += -Math.sin(_player.angle) * Player.maxAcceleration * gameClock.deltaTime;			}			*/			if (hm.keyboard.switchWeaponPressed && (gameClock.currentTime-switchWeaponLastTime)>=switchWeaponDelayTime) { 				switchWeaponLastTime = gameClock.currentTime;								switch(currentWeapon) {					case 1:						currentWeapon = 2;						_player.currentWeapon = 2;						_gameHUD.setCurrentWeapon(currentWeapon);						crossHairType = 2;						break;					case 2:						currentWeapon = 1;						_player.currentWeapon = 1;						_gameHUD.setCurrentWeapon(currentWeapon);						crossHairType = 1;						break;				}				changeCrossHair();				se.playSound("switchWeaponSound");				/*				if (currentWeapon < 2) {					_player.currentWeapon = ++currentWeapon;					_gameHUD.setCurrentWeapon(currentWeapon);				}				 if (currentWeapon > 1) {					_player.currentWeapon = --currentWeapon;					_gameHUD.setCurrentWeapon(currentWeapon);				}				*/			}						if (hm.keyboard.spacePressed) {				createPlayerProjectile();			}						if (hm.keyboard.pausePressed) {				dispatchEvent(new APEvent(APEvent.SHOW_PAUSE));			}						/*			if (hm.keyboard.upPressed && (gameClock.currentTime-switchCrossHairLastTime)>=switchCrossHairDelayTime) { 				switchCrossHairLastTime = gameClock.currentTime;								switch(crossHairType) {					case 1:						crossHairType = 2;						break;					case 2:						crossHairType = 1;						break;				}				changeCrossHair();			}			*/			/*var movement:Vector3D = _config.playerMovement.clone();			movement.scaleBy(_deltaTime);			if (_keyLeftPressed) {				_player.netForce.decrementBy(movement);			}			if (_keyRightPressed) {				_player.netForce.incrementBy(movement);			}*/		}				function changeCrossHair():void {			var temp:CrossHair; 						switch(crossHairType) {				case 1:					temp = new lm.crossHair1Class();					break;				case 2:					temp = new lm.crossHair2Class();					break;				case 3:					break;			}			removeChild(_crossHair as DisplayObject);			_crossHair = temp;			_crossHair.scaleX = _crossHairScale;			_crossHair.scaleY = _crossHairScale;			addChild(_crossHair);					} 				function resetCrossHair(level:DisplayObject):void {			_crossHair.alpha = 1;			_crossHair.tempX = mouseX;			_crossHair.tempY = mouseY;			(level as MovieClip).getChildByName("enterLevelText").alpha = 0.0;		}				function checkCrossHair():void {			if (_crossHair.alpha == 0)				return;			var testCrossHair:Rectangle = _crossHair.getRect(this as DisplayObject);			for each (var level:DisplayObject in _levels) {				var testLevel:Rectangle = level.getRect(this as DisplayObject);				if (testLevel.intersects(testCrossHair)) {					(level as MovieClip).getChildByName("enterLevelText").alpha = 1.0;					_crossHair.alpha = 0;					_crossHair.tempX = -SCREEN_WIDTH*2;					TweenLite.delayedCall(1.0, resetCrossHair, [level], false);					return;				}			}						_crossHair.tempX = mouseX;			_crossHair.tempY = mouseY;						if (!crossHairLock)				_crossHair.gotoAndStop(1);						if ( !crossHairLock && _player.directionToTurn == 1) {				_crossHair.angle += (_player.maxSteering * (_player.velocity.length / _player.maxSpeed));				crossHairLastDirection = 1;			}			else if ( !crossHairLock && _player.directionToTurn == -1) {				_crossHair.angle -= (_player.maxSteering * (_player.velocity.length / _player.maxSpeed));				crossHairLastDirection = -1;			}			else if (!crossHairLock) {				if( crossHairLastDirection == 1)					_crossHair.angle += (_player.maxSteering * (_player.velocity.length / _player.maxSpeed));				else					_crossHair.angle -= (_player.maxSteering * (_player.velocity.length / _player.maxSpeed));			}						crossHairLock = false;			for each (var enemy:IEnemy in _enemyList) {				testCrossHair = _crossHair.getRect(this as DisplayObject);				var testEnemy:Rectangle = enemy.getRect(this as DisplayObject);				if (testEnemy.intersects(testCrossHair)) {					crossHairLock = true;					_crossHair.gotoAndStop(2);				}			}									}				function changePlayerState():void {			var temp:IPlayer; 						switch(_player.playerState) {				case 1:					if(playerMovementPlane == 1)						temp = new lm.playerUpClass();					else 						temp = new lm.playerDownClass();					_playerProjectileSpeed = 20;					playerShotDelayTime = 1000;					break;				case 2:					if(playerMovementPlane == 1)						temp = new lm.playerUp2Class();					else 						temp = new lm.playerDown2Class();					_playerProjectileSpeed = 40;					playerShotDelayTime = 500;					break;				case 3:					if(playerMovementPlane == 1)						temp = new lm.playerUp3Class();					else 						temp = new lm.playerDown3Class();					_playerProjectileSpeed = 80;					playerShotDelayTime = 250;					break;			}			temp.x = _player.x;			temp.y = _player.y;			temp.tempX = _player.x;			temp.tempY = _player.y;			temp.tempRotation = _player.rotation;			temp.angle = _player.angle;			temp.velocity = _player.velocity;			temp.acceleration = _player.acceleration;			temp.health = _player.health;			temp.shieldHealth = _player.shieldHealth;			temp.playerState = _player.playerState;			if(playerMovementPlane == 1) {				(_layerList[1] as MovieClip).removeChild(_player as DisplayObject);				_player = temp;				(_layerList[1] as MovieClip).addChildAt(_player as DisplayObject,(_layerList[1] as MovieClip).numChildren);				}			else {				(_layerList[0] as MovieClip).removeChild(_player as DisplayObject);				_player = temp;				(_layerList[0] as MovieClip).addChildAt(_player as DisplayObject,(_layerList[0] as MovieClip).numChildren);			}											Missile.maxSpeed = _player.maxSpeed * 4; 			Missile.maxSteering = _player.maxSteering * 2;			Missile.maxAcceleration = _player.maxAcceleration * 4; 			Missile.minAcceleration = _player.minAcceleration * 4; 						switchingPlayerState = false;		} 				function moveUpLevel():void {						if (_player.health <= 0 && _player.shieldHealth <= 0) {				switchingPlane = false;				return;			}						var temp:IPlayer; 						switch(_player.playerState) {				case 1:					temp = new lm.playerUpClass();					break;				case 2:					temp = new lm.playerUp2Class();					break;				case 3:					temp = new lm.playerUp3Class();					break;			}				temp.x = _player.x;			temp.y = _player.y;			temp.tempX = _player.x;			temp.tempY = _player.y;			temp.tempRotation = _player.rotation;			temp.angle = _player.angle;			temp.velocity = _player.velocity;			temp.acceleration = _player.acceleration;			temp.health = _player.health;			temp.shieldHealth = _player.shieldHealth;			temp.playerState = _player.playerState;			(_layerList[0] as MovieClip).removeChild(_player as DisplayObject);			_player = temp;			_player.x = _player.tempX;			_player.y = _player.tempY;			_player.rotation = _player.tempRotation;			(_layerList[1] as MovieClip).addChildAt(_player as DisplayObject, (_layerList[1] as MovieClip).numChildren);						playerMovementPlane = 1;			switchingPlane = false;		} 				function moveDownLevel():void {						if (_player.health <= 0 && _player.shieldHealth <= 0) {				switchingPlane = false;				return;			}						var temp:IPlayer; 						switch(_player.playerState) {				case 1:					temp = new lm.playerDownClass();					break;				case 2:					temp = new lm.playerDown2Class();					break;				case 3:					temp = new lm.playerDown3Class();					break;			}				temp.x = _player.x;			temp.y = _player.y;			temp.tempX = _player.x;			temp.tempY = _player.y;			temp.tempRotation = _player.rotation;			temp.angle = _player.angle;			temp.velocity = _player.velocity;			temp.acceleration = _player.acceleration;			temp.health = _player.health;			temp.shieldHealth = _player.shieldHealth;			temp.playerState = _player.playerState;			(_layerList[1] as MovieClip).removeChild(_player as DisplayObject);			_player = temp;			_player.x = _player.tempX;			_player.y = _player.tempY;			_player.rotation = _player.tempRotation;			(_layerList[0] as MovieClip).addChildAt(_player as DisplayObject, (_layerList[0] as MovieClip).numChildren);						playerMovementPlane = -1;			switchingPlane = false;		} 				/*		protected function playerSwitchPlane():void {			if (_player.isJumping || _player.isFalling) return;			_player.isJumping = true;			var jump:Vector3D = _config.playerJump.clone();			_player.netForce.incrementBy(jump);		}		*/		protected function applyForces():void {			/*var gravity:Vector3D = _config.gravity.clone();			gravity.scaleBy(_deltaTime);			_player.netForce.incrementBy(gravity);			if (_player.isJumping) {				_player.netForce.x *= _config.drag;			} else {				_player.netForce.x *= _config.friction;			}*/		}				protected function movePlayer():void {			_player.velocity.scaleBy(Player.friction);			_player.velocity = _player.velocity.add(_player.acceleration);			_player.tempX += _player.velocity.x * gameClock.deltaTime;			_player.tempY += _player.velocity.y * gameClock.deltaTime;						var playerPoint:Point = _background.localToGlobal(new Point(_player.tempX, _player.tempY));						if ( playerPoint.x < borderBoundaryDistance) {				_player.tempX = _background.globalToLocal(new Point(borderBoundaryDistance,0)).x;			}			if ( playerPoint.x > (SCREEN_WIDTH - borderBoundaryDistance) ) {				_player.tempX = _background.globalToLocal(new Point(SCREEN_WIDTH - borderBoundaryDistance,0)).x;			}			if ( playerPoint.y < borderBoundaryDistance) {				_player.tempY = _background.globalToLocal(new Point(0,borderBoundaryDistance)).y;			}			if (playerPoint.y > (SCREEN_HEIGHT - borderBoundaryDistance) ) { 				_player.tempY = _background.globalToLocal(new Point(0,SCREEN_HEIGHT - borderBoundaryDistance)).y;			}					}		protected function createAsteroids():void {			var i:int;			var minY:int;			var maxY:int;			var minX:int;			var maxX:int;			var asteroidPoint:Point;						asteroid = new lm.asteroidGroupClass();			minY = asteroid.height + borderBoundaryDistance;			maxY = (_background.r_img.height) - asteroid.height - borderBoundaryDistance;			minX = asteroid.width + borderBoundaryDistance;			maxX = (_background.r_img.width) - asteroid.width - borderBoundaryDistance;						if (_asteroidList.length == 0) {				var asteroid:IAsteroid;				for (i = 0; i < 3; i++) {										asteroid = new lm.asteroidGroupClass();					asteroid.speed = _asteroidSpeed;										asteroid.angle = Math.random() * 6.28;					asteroid.tempRotation = asteroid.angle;					asteroid.rotation = asteroid.tempRotation * (180 / Math.PI);									asteroid.tempX = asteroid.x   =  Math.floor(Math.random() * (1 + maxX - minX)) + minX;					asteroid.tempY = asteroid.y = Math.floor(Math.random() * (1+maxY-minY)) + minY;												asteroidPoint = _background.localToGlobal(new Point(asteroid.tempX, asteroid.tempY));										/*					while ( asteroidPoint.x > 0 					&& asteroidPoint.x < SCREEN_WIDTH					&& asteroidPoint.y > 0					&& asteroidPoint.y < SCREEN_HEIGHT) { 						asteroid.tempX = asteroid.x = Math.floor(Math.random() * (1 + maxX - minX)) + minX;						asteroid.tempY = asteroid.y = Math.floor(Math.random() * (1+maxY-minY)) + minY;					}					*/										_asteroidList.push(asteroid);					(asteroid as DisplayObject).scaleX = 0.1;					(asteroid as DisplayObject).scaleY = 0.1;										(_layerList[1] as MovieClip).addChild(asteroid as DisplayObject);					TweenLite.to(asteroid as DisplayObject, 0.5, { scaleX:1.0, scaleY:1.0 } );				}								asteroid = new lm.asteroidSingleClass();				minY = asteroid.height + borderBoundaryDistance;				maxY = (_background.r_img.height) - asteroid.height - borderBoundaryDistance;				minX = asteroid.width + borderBoundaryDistance;				maxX = (_background.r_img.width) - asteroid.width - borderBoundaryDistance;								for (i = 0; i < 6; i++) {										asteroid = new lm.asteroidSingleClass();					asteroid.speed = _asteroidSpeed;										asteroid.angle = Math.random() * 6.28;					asteroid.tempRotation = asteroid.angle;					asteroid.rotation = asteroid.tempRotation * (180 / Math.PI);										asteroid.tempX = asteroid.x = Math.floor(Math.random() * (1 + maxX - minX)) + minX;					asteroid.tempY = asteroid.y = Math.floor(Math.random() * (1+maxY-minY)) + minY;										asteroidPoint = _background.localToGlobal(new Point(asteroid.tempX, asteroid.tempY));										/*					while ( asteroidPoint.x > 0 					&& asteroidPoint.x < SCREEN_WIDTH					&& asteroidPoint.y > 0					&& asteroidPoint.y < SCREEN_HEIGHT) { 						asteroid.tempX = asteroid.x = Math.floor(Math.random() * (1 + maxX - minX)) + minX;						asteroid.tempY = asteroid.y = Math.floor(Math.random() * (1+maxY-minY)) + minY;					}					*/							_asteroidList.push(asteroid);										(asteroid as DisplayObject).scaleX = 0.1;					(asteroid as DisplayObject).scaleY = 0.1;										(_layerList[1] as MovieClip).addChild(asteroid as DisplayObject);					TweenLite.to(asteroid as DisplayObject, 0.5, { scaleX:1.0, scaleY:1.0 } );				}			}		}				protected function removeAsteroid(asteroid:DisplayObject):void {			var explosionSprite = new lm.explosionClass();			var orbX:int = explosionSprite.x = asteroid.x;			var orbY:int = explosionSprite.y = asteroid.y;			var asteroidType:int;			if (asteroid is AsteroidSingle) {				asteroidType = 1;			}			else {				asteroidType = 2;			}			if (asteroid.parent == (_layerList[1] as MovieClip)) (_layerList[1] as MovieClip).removeChild(asteroid);			_asteroidList.splice(_asteroidList.indexOf(asteroid), 1);			(_layerList[1] as MovieClip).addChild(explosionSprite as DisplayObject);			TweenLite.delayedCall(10, (_layerList[1] as MovieClip).removeChild, [explosionSprite], true);						var minY:int;			var maxY:int;			var minX:int;			var maxX:int;			var orbColor:String;			var orbType:String;			var itemSprite:IItem;						if (asteroidType == 1) {						switch(Math.floor(Math.random() * 2) + 1) {					case 1:						orbColor = "blueOrb";						orbType = "BlueOrb";						itemSprite = new lm.blueOrbClass();						itemSprite.points = 100;						break;					case 2:						orbColor = "yellowOrb";						orbType = "YellowOrb";						itemSprite = new lm.yellowOrbClass();						itemSprite.points = 50;						break;				}								minY = orbY - itemSprite.height;				maxY = orbY + itemSprite.height;				minX = orbX - itemSprite.height;				maxX = orbX + itemSprite.height;				itemSprite.x  = Math.floor(Math.random() * (1 + maxX - minX)) + minX;				itemSprite.y  = Math.floor(Math.random() * (1+maxY-minY)) + minY;				itemSprite.name = orbColor;				itemSprite.type = orbType;								if ( itemSprite.x < itemSprite.width + borderBoundaryDistance ){					itemSprite.x = itemSprite.width + borderBoundaryDistance;				}				if ( itemSprite.x > ((_background.r_img.width) - itemSprite.width - borderBoundaryDistance) ) {					itemSprite.x = ((_background.r_img.width) - itemSprite.width - borderBoundaryDistance);				}				if ( itemSprite.y < itemSprite.height + borderBoundaryDistance ){					itemSprite.y = itemSprite.height + borderBoundaryDistance;				}				if ( itemSprite.y > ((_background.r_img.height) - itemSprite.height - borderBoundaryDistance) ) {					itemSprite.y = ((_background.r_img.height) - itemSprite.height - borderBoundaryDistance);				}								_items.push(itemSprite);				(_layerList[1] as MovieClip).addChild(itemSprite as DisplayObject);			}			else {				for (var i:int = 1; i <= 4; i++) {					switch(i) {						case 1:							orbColor = "blueOrb";							orbType = "BlueOrb";							itemSprite = new lm.blueOrbClass();							itemSprite.points = 100;							break;						case 2:							orbColor = "yellowOrb";							orbType = "YellowOrb";							itemSprite = new lm.yellowOrbClass();							itemSprite.points = 50;							break;						case 3:							orbColor = "redOrb";							orbType = "RedOrb";							itemSprite = new lm.redOrbClass();							itemSprite.points = 10;							break;						case 4:							orbColor = "greenOrb";							orbType = "greenOrb";							itemSprite = new lm.greenOrbClass();							itemSprite.points = 30;							break;					}										minY = orbY - itemSprite.height;					maxY = orbY + itemSprite.height;					minX = orbX - itemSprite.height;					maxX = orbX + itemSprite.height;					itemSprite.x  = Math.floor(Math.random() * (1 + maxX - minX)) + minX;					itemSprite.y  = Math.floor(Math.random() * (1 + maxY - minY)) + minY;					itemSprite.name = orbColor;					itemSprite.type = orbType;										if ( itemSprite.x < itemSprite.width + borderBoundaryDistance ){						itemSprite.x = itemSprite.width + borderBoundaryDistance;					}					if ( itemSprite.x > ((_background.r_img.width) - itemSprite.width - borderBoundaryDistance) ) {						itemSprite.x = ((_background.r_img.width) - itemSprite.width - borderBoundaryDistance);					}					if ( itemSprite.y < itemSprite.height + borderBoundaryDistance ){						itemSprite.y = itemSprite.height + borderBoundaryDistance;					}					if ( itemSprite.y > ((_background.r_img.height) - itemSprite.height - borderBoundaryDistance) ) {						itemSprite.y = ((_background.r_img.height) - itemSprite.height - borderBoundaryDistance);					}										_items.push(itemSprite);					(_layerList[1] as MovieClip).addChild(itemSprite as DisplayObject);				}			}		}				protected function moveAsteroids():void {			for each (var asteroid:IAsteroid in _asteroidList) {				var xSpeed:Number = Math.cos(asteroid.tempRotation) * asteroid.speed;				var ySpeed:Number = Math.sin(asteroid.tempRotation) * asteroid.speed;				asteroid.tempX += xSpeed;				asteroid.tempY += ySpeed;								if (asteroid.tempY > _background.r_img.height					|| asteroid.tempY < 0					|| asteroid.tempX > _background.r_img.width 					|| asteroid.tempX  < 0) {					removeAsteroid(asteroid as DisplayObject);				}					}		}				protected function checkAsteroidCollisions():void {						for each (var asteroid:IAsteroid in _asteroidList) {				var testAsteroid:Rectangle = asteroid.getRect(this as DisplayObject);				for each (var projectile:IProjectile in _playerProjectileList) {					var testProjectile:Rectangle = projectile.getRect(this as DisplayObject);									if (testAsteroid.intersects(testProjectile)) {						if(projectile is Laser) {							asteroid.health --;						}						else {							asteroid.health -= 2;						}						var damage1Sprite = new lm.enemyDamage1Class();						damage1Sprite.x = projectile.x;						damage1Sprite.y = projectile.y;						damage1Sprite.rotation = projectile.rotation;						(_layerList[1] as MovieClip).addChild(damage1Sprite as DisplayObject);												var xDest = Math.cos(damage1Sprite.rotation*(Math.PI/180)) * 5;						var yDest = Math.sin(damage1Sprite.rotation*(Math.PI/180)) * 5;												TweenLite.to(damage1Sprite as DisplayObject, 0.1, {x:damage1Sprite.x+xDest,y:damage1Sprite.y+yDest,onComplete:enemyDamageEffect, onCompleteParams:[damage1Sprite]});												removePlayerProjectile(projectile as DisplayObject);												if (asteroid.health <= 0) {								var variationToPlay:int = (Math.floor(Math.random() * se.variations("explosionSound1")) + 1);							se.playSound("explosionSound" + variationToPlay);							removeAsteroid(asteroid as DisplayObject);						}					}				}				}		}					protected function moveEnemies():void {						if ( _currentLevel != 0 && _enemyList.length == 0 ) {				_levelCleared = true;			}						if ( _currentLevel != 0 && _enemyList.length == 0 && _items.length == 0) {				stopGame();				dispatchEvent(new APEvent(APEvent.LEVEL_COMPLETE));				se.playSound("levelCompleteStinger");				return;			}						var playerPoint:Point = _background.localToGlobal(new Point(_player.tempX, _player.tempY));						for each (var enemy:IEnemy in _enemyList) {				var randomBehavior:Number;				switch(_enemyList.indexOf(enemy) % 3) {					case 0:						randomBehavior = 0.5;						break;					case 1:						randomBehavior = 1.0;						break;					case 2:						randomBehavior = 1.5;						break;				}								var enemyPoint:Point = _background.localToGlobal(new Point(enemy.x, enemy.y));				if ( enemy is Turret && enemyPoint.y > borderBoundaryDistance 					&& enemyPoint.y < (SCREEN_HEIGHT - borderBoundaryDistance) 					&& enemyPoint.x > borderBoundaryDistance					&& enemyPoint.x < (SCREEN_WIDTH - borderBoundaryDistance )) {						if ( enemy.directionToTurn(playerPoint, enemyPoint) == 1) {						enemy.angle -= Turret.maxSteering * randomBehavior;					}					else if ( enemy.directionToTurn(playerPoint, enemyPoint) == -1 ){						enemy.angle += Turret.maxSteering * randomBehavior;					}					createEnemyProjectile(enemy);				}				else if ( enemy is FlyingEnemy ) {					enemy.acceleration = new Vector3D();										if (enemy.playerSpotted) {						if ( enemy.directionToTurn(playerPoint, enemyPoint) == 1) {							//enemy.angle -= FlyingEnemy.maxSteering;							enemy.angle -= (FlyingEnemy.maxSteering * (enemy.velocity.length / (FlyingEnemy.maxSpeed) ) * randomBehavior);						}						else if ( enemy.directionToTurn(playerPoint, enemyPoint) == -1 ) {							//enemy.angle += FlyingEnemy.maxSteering;							enemy.angle += (FlyingEnemy.maxSteering * (enemy.velocity.length / (FlyingEnemy.maxSpeed) ) * randomBehavior);						}												if (Point.distance(playerPoint,enemyPoint) < SCREEN_HEIGHT/4 ) {							enemy.acceleration.x += Math.cos(enemy.angle-Math.PI/2) * FlyingEnemy.minAcceleration * gameClock.deltaTime * randomBehavior;							enemy.acceleration.y += Math.sin(enemy.angle-Math.PI/2) * FlyingEnemy.minAcceleration * gameClock.deltaTime * randomBehavior;						}						else {							enemy.acceleration.x += Math.cos(enemy.angle-Math.PI/2) * FlyingEnemy.maxAcceleration * gameClock.deltaTime * randomBehavior;							enemy.acceleration.y += Math.sin(enemy.angle-Math.PI/2) * FlyingEnemy.maxAcceleration * gameClock.deltaTime * randomBehavior;						}												enemy.velocity.scaleBy(FlyingEnemy.friction);						enemy.velocity = enemy.velocity.add(enemy.acceleration);						enemy.tempX += enemy.velocity.x * gameClock.deltaTime;						enemy.tempY += enemy.velocity.y * gameClock.deltaTime;					}					if ( enemyPoint.y > borderBoundaryDistance 					&& enemyPoint.y < (SCREEN_HEIGHT - borderBoundaryDistance) 					&& enemyPoint.x > borderBoundaryDistance					&& enemyPoint.x < (SCREEN_WIDTH - borderBoundaryDistance) ) {						if ( !enemy.playerSpotted )							enemy.playerSpotted = true;						createEnemyProjectile(enemy);					}				}			}						/*for each (var enemy:IEnemy in _enemies) {				var motion:Vector3D = enemy.motion.clone();				motion.scaleBy(_deltaTime);				enemy.tempX = enemy.x + motion.x;				enemy.tempY = enemy.y + motion.y;				//CHECK WALL COLLISIONS				var testReference:GridReference = getCollisionReference(enemy);				var enemyRect:Rectangle = enemy.hitArea.getRect(this);				var oldRect:Rectangle = enemyRect.clone();				enemyRect.offset(enemy.tempX - enemy.x, enemy.tempY - enemy.y);				for each (var wall:IWall in testReference.walls) {					var wallRect:Rectangle = wall.getRect(this);					var intersection:Rectangle = wallRect.intersection(enemyRect);					if (!intersection.width || !intersection.height) continue;					if (wallRect.right <= oldRect.left) { //WALL IS TO THE LEFT						enemyRect.x += intersection.width;						enemy.motion.x *= -1;					}					if (wallRect.left >= oldRect.right) { //WALL IS TO THE RIGHT						enemyRect.x -= intersection.width;						enemy.motion.x *= -1;					}				}				enemy.tempX = enemy.x + enemyRect.x - oldRect.x;				enemy.tempY = enemy.y + enemyRect.y - oldRect.y;			}			*/		}				protected function checkPlayerCollisions():void {						var testPlayer:Rectangle = _player.getRect(this as DisplayObject);			for each (var projectile:IProjectile in _enemyProjectileList) {				var testProjectile:Rectangle = projectile.getRect(this as DisplayObject);				var variationToPlay:int;				if (testPlayer.intersects(testProjectile)) {					if (_player.shieldHealth > 0 ) {						_player.shieldHealth -= projectile.strength;						variationToPlay = (Math.floor(Math.random() * se.variations("shieldHitSound1")) + 1);						se.playSound("shieldHitSound" + variationToPlay);												if (_player.shieldHealth < 0) {							_player.shieldHealth = 0;							_gameHUD.minYellowBar();							se.playSound("shieldDepletedSound");						}						numYellowOrbs = _player.shieldHealth;					}					else {						_player.health -= projectile.strength;												variationToPlay = (Math.floor(Math.random() * se.variations("damageSound1")) + 1);						se.playSound("damageSound" + variationToPlay);												if (_player.health < 0) {							_player.health = 0;							_gameHUD.minBlueBar();							se.playSound("orbBarEmptySound");						} 						numBlueOrbs = _player.health;					}					var damage1Sprite = new lm.enemyDamage1Class();					damage1Sprite.x = projectile.x;					damage1Sprite.y = projectile.y;					damage1Sprite.rotation = projectile.rotation;					(_layerList[1] as MovieClip).addChild(damage1Sprite as DisplayObject);										var xDest = Math.cos(damage1Sprite.rotation*(Math.PI/180)) * 5;					var yDest = Math.sin(damage1Sprite.rotation*(Math.PI/180)) * 5;										TweenLite.to(damage1Sprite as DisplayObject, 0.1, {x:damage1Sprite.x+xDest,y:damage1Sprite.y+yDest,onComplete:enemyDamageEffect, onCompleteParams:[damage1Sprite]});										removeEnemyProjectile(projectile as DisplayObject);										if (_player.shieldHealth == 0 && _player.health == 0) {							var explosionSprite = new lm.explosionClass();							explosionSprite.x = _player.x;							explosionSprite.y = _player.y;							_crossHair.alpha = 0;														if(playerMovementPlane == 1) {								(_layerList[1] as MovieClip).removeChild(_player as DisplayObject);								(_layerList[1] as MovieClip).addChild(explosionSprite as DisplayObject);								TweenLite.delayedCall(10, (_layerList[1] as MovieClip).removeChild, [explosionSprite], true);							}							else {								(_layerList[0] as MovieClip).removeChild(_player as DisplayObject);								(_layerList[0] as MovieClip).addChild(explosionSprite as DisplayObject);								TweenLite.delayedCall(10, (_layerList[0] as MovieClip).removeChild, [explosionSprite], true);							}							variationToPlay = (Math.floor(Math.random() * se.variations("explosionSound1")) + 1);							se.playSound("explosionSound" + variationToPlay);							stopGame();							removeAllProjectiles();							se.playSound("playerDeadStinger");							TweenLite.delayedCall(5, respawnPlayer, null, false);					}				}							}						}				protected function respawnPlayer():void {			_player.shieldHealth = 100;			numYellowOrbs = _player.shieldHealth;			(_player as DisplayObject).filters = new Array();						if(playerMovementPlane == 1) {				(_layerList[1] as MovieClip).addChildAt(_player as DisplayObject, (_layerList[1] as MovieClip).numChildren);			}			else {				(_layerList[0] as MovieClip).addChildAt(_player as DisplayObject, (_layerList[0] as MovieClip).numChildren);			}						_crossHair.alpha = 1;			startGame();		}				protected function checkItems():void {			var item:IItem;						if (gameClock.currentTime-lastOrbSpawnTime >= orbDelayTime && !_levelCleared) {								lastOrbSpawnTime = gameClock.currentTime; 								// delete all orbs on screen				for each (item in _items) {					_items.splice(_items.indexOf(item), 1);					(_layerList[1] as MovieClip).removeChild(item as DisplayObject);				}								for(var i:int=1;i<=numOrbsToSpawn;i++){										var orbColor:String;					var orbType:String;					var itemSprite:IItem;					switch(Math.floor(Math.random() * 3) + 1) {						case 1:							orbColor = "redOrb";							orbType = "RedOrb";							itemSprite = new lm.redOrbClass();							itemSprite.points = 10;							break;						case 2:							orbColor = "yellowOrb";							orbType = "YellowOrb";							itemSprite = new lm.yellowOrbClass();							itemSprite.points = 50;							break;						case 3:							orbColor = "greenOrb";							orbType = "greenOrb";							itemSprite = new lm.greenOrbClass();							itemSprite.points = 30;							break;					}															itemSprite.name = orbColor;					itemSprite.type = orbType;										var minY:int = itemSprite.height + borderBoundaryDistance;					var maxY:int = (_background.r_img.height) - itemSprite.height - borderBoundaryDistance;					var minX:int = itemSprite.width + borderBoundaryDistance;					var maxX:int = (_background.r_img.width) - itemSprite.width - borderBoundaryDistance;					var rowSize:int = maxY/numOrbsToSpawn;					itemSprite.x  = Math.floor(Math.random() * (1 + maxX - minX)) + minX;					itemSprite.y  = Math.floor(Math.random() * (1+maxY-minY)) + minY;												_items.push(itemSprite);					(_layerList[1] as MovieClip).addChild(itemSprite as DisplayObject);				}			}						//var testSprite:Sprite = _player.get;			//var testRect:Rectangle = testSprite.getRect(this as DisplayObject);			var testRect:Rectangle = _player.getRect(this as DisplayObject);			for each (item in _items) {				//var itemRect:Rectangle = item.hitArea.getRect(this as DisplayObject);								var itemRect:Rectangle = item.getRect(this as DisplayObject);				if (testRect.intersects(itemRect)) {					if (item.name == "redOrb") {						numRedOrbs += 10;						if (numRedOrbs >= 30) {							numRedOrbs = 30;							_gameHUD.maxRedBar();							se.playSound("orbBarFullSound");						}					}					else if (item.name == "blueOrb") {						numBlueOrbs += 1;						if (numBlueOrbs >= 30) {							numBlueOrbs = 30;							_gameHUD.maxBlueBar();							se.playSound("orbBarFullSound");						}						_player.health = numBlueOrbs;					}					else if (item.name == "greenOrb") {						numGreenOrbs += 3;						if (numGreenOrbs >= 30) {							numGreenOrbs = 30;							_gameHUD.maxGreenBar();							se.playSound("orbBarFullSound");						}					}					else if (item.name == "yellowOrb") {						numYellowOrbs += 20;						if (numYellowOrbs >= 100) {							numYellowOrbs = 100;							_gameHUD.maxYellowBar();							se.playSound("orbBarFullSound");						}						_player.shieldHealth = numYellowOrbs; 					}										var variationToPlay:int = (Math.floor(Math.random() * se.variations("collectOrbSound1")) + 1);					se.playSound("collectOrbSound" + variationToPlay);										_score += item.points;					_items.splice(_items.indexOf(item), 1);					TweenLite.to(item as DisplayObject, 0.5, {blurFilter:{blurX:50, blurY:50}, onComplete:removeOrb, onCompleteParams:[item as DisplayObject]});				}			}						if ( numBlueOrbs < 7 && _player.playerState != 1 && !switchingPlane ) {				_player.playerState = 1;				switchingPlayerState = true;				TweenLite.to(_player as DisplayObject, 1.5, { blurFilter: { blurX:10, blurY:10 }, onComplete:changePlayerState } );				se.playSound("planeEvolveDevolveSound");			}			else if (numBlueOrbs >= 7 && _player.playerState < 2 && !switchingPlane) {				_player.playerState = 2;				switchingPlayerState = true;				TweenLite.to(_player as DisplayObject, 1.5, { blurFilter: { blurX:10, blurY:10 }, onComplete:changePlayerState } );				se.playSound("planeEvolveDevolveSound");			}			else if (numBlueOrbs >= 18 && _player.playerState < 3 && !switchingPlane) {				_player.playerState = 3;				switchingPlayerState = true;				TweenLite.to(_player as DisplayObject, 1.5, { blurFilter: { blurX:10, blurY:10 }, onComplete:changePlayerState } );				se.playSound("planeEvolveDevolveSound");			}		}				protected function removeOrb(item:DisplayObject):void {						if (item.parent == (_layerList[1] as MovieClip)) (_layerList[1] as MovieClip).removeChild(item);			_inventory.push(item);			dispatchEvent(new APEvent(APEvent.INVENTORY_UPDATE,item.name));		}				protected function checkEnemyCollisions():void {						for each (var enemy:IEnemy in _enemyList) {				var testEnemy:Rectangle = enemy.getRect(this as DisplayObject);				for each (var projectile:IProjectile in _playerProjectileList) {					var testProjectile:Rectangle = projectile.getRect(this as DisplayObject);										if (testEnemy.intersects(testProjectile)) {						var variationToPlay:int;						if(projectile is Laser) {							enemy.health -= projectile.strength * 4;						}						else {							enemy.health -= projectile.strength;						}						var damage1Sprite = new lm.enemyDamage1Class();						damage1Sprite.x = projectile.x;						damage1Sprite.y = projectile.y;						damage1Sprite.rotation = projectile.rotation;						(_layerList[1] as MovieClip).addChild(damage1Sprite as DisplayObject);												var xDest = Math.cos(damage1Sprite.rotation*(Math.PI/180)) * 5;						var yDest = Math.sin(damage1Sprite.rotation*(Math.PI/180)) * 5;												TweenLite.to(damage1Sprite as DisplayObject, 0.1, {x:damage1Sprite.x+xDest,y:damage1Sprite.y+yDest,onComplete:enemyDamageEffect, onCompleteParams:[damage1Sprite]});												removePlayerProjectile(projectile as DisplayObject);												variationToPlay = (Math.floor(Math.random() * se.variations("damageSound1")) + 1);						se.playSound("damageSound" + variationToPlay);												if (enemy.health <= 0) {								variationToPlay = (Math.floor(Math.random() * se.variations("explosionSound1")) + 1);							se.playSound("explosionSound" + variationToPlay);							removeEnemy(enemy as DisplayObject);						}					}				}				}												/*var testRect:Rectangle = _player.hitArea.getRect(this);			for each (var enemy:IEnemy in testReference.enemies) {				var enemyRect:Rectangle = enemy.hitArea.getRect(this);				if (testRect.intersects(enemyRect)) {					var enemyPoint:Point = getGridPosition(enemy);					var gridReference:GridReference = _collisionGrid.getGridReference(enemyPoint.x, enemyPoint.y);					gridReference.removeEnemy(enemy);					_enemies.splice(_enemies.indexOf(enemy),1);					removeChild(enemy as DisplayObject);					var pe:PlatformerEvent = new PlatformerEvent(PlatformerEvent.PLAYER_DIE, enemy.name);					dispatchEvent(pe);				}			}*/		}				protected function enemyDamageEffect(damage1Sprite:DisplayObject) {						var damage2Sprite = new lm.enemyDamage2Class();			damage2Sprite.x = damage1Sprite.x;			damage2Sprite.y = damage1Sprite.y;			damage2Sprite.rotation = damage1Sprite.rotation;			(_layerList[1] as MovieClip).removeChild(damage1Sprite);			(_layerList[1] as MovieClip).addChild(damage2Sprite as DisplayObject);			var xDest = Math.cos(damage2Sprite.rotation*(Math.PI/180)) * 5;			var yDest = Math.sin(damage2Sprite.rotation*(Math.PI/180)) * 5;									TweenLite.to(damage2Sprite as DisplayObject, 0.1, {x:damage2Sprite.x+xDest,y:damage2Sprite.y+yDest,onComplete:(_layerList[1] as MovieClip).removeChild, onCompleteParams:[damage2Sprite]});		}				protected function removeEnemy(enemy:DisplayObject):void {			var explosionSprite = new lm.explosionClass();			var orbX:int = explosionSprite.x = enemy.x;			var orbY:int = explosionSprite.y = enemy.y;			if (enemy.parent == (_layerList[1] as MovieClip)) (_layerList[1] as MovieClip).removeChild(enemy);			_enemyList.splice(_enemyList.indexOf(enemy), 1);			(_layerList[1] as MovieClip).addChild(explosionSprite as DisplayObject);			TweenLite.delayedCall(10, (_layerList[1] as MovieClip).removeChild, [explosionSprite], true);						for(var i:int=0;i<3;i++){									var orbColor:String;				var orbType:String;				var itemSprite:IItem;						orbColor = "blueOrb";				orbType = "BlueOrb";								itemSprite = new lm.blueOrbClass();				itemSprite.points = 100;				itemSprite.name = orbColor;				itemSprite.type = orbType;								var minY:int = orbY - itemSprite.height;				var maxY:int = orbY + itemSprite.height;				var minX:int = orbX - itemSprite.height;				var maxX:int = orbX + itemSprite.height;				itemSprite.x  = Math.floor(Math.random() * (1 + maxX - minX)) + minX;				itemSprite.y  = Math.floor(Math.random() * (1+maxY-minY)) + minY;								if ( itemSprite.x < itemSprite.width + borderBoundaryDistance ){					itemSprite.x = itemSprite.width + borderBoundaryDistance;				}				if ( itemSprite.x > ((_background.r_img.width) - itemSprite.width - borderBoundaryDistance) ) {					itemSprite.x = ((_background.r_img.width) - itemSprite.width - borderBoundaryDistance);				}				if ( itemSprite.y < itemSprite.height + borderBoundaryDistance ){					itemSprite.y = itemSprite.height + borderBoundaryDistance;				}				if ( itemSprite.y > ((_background.r_img.height) - itemSprite.height - borderBoundaryDistance) ) {					itemSprite.y = ((_background.r_img.height) - itemSprite.height - borderBoundaryDistance);				}								_items.push(itemSprite);				(_layerList[1] as MovieClip).addChild(itemSprite as DisplayObject);			}																}				/*protected function checkInventory(name:String):Boolean {			var found:Boolean = false;			for (var i:int = 0; i < _inventory.length; i++) {				if (_inventory[i].name == name) {					found = true;					break;				}			}			return found;		}*/			protected function createPlayerProjectile():void {			if (_gameRunning && (gameClock.currentTime-playerLastShotTime)>=(playerShotDelayTime*Math.random())) {				playerLastShotTime = gameClock.currentTime; 				var projectileL:IProjectile;				var projectileR:IProjectile;				var variationToPlay:int;								switch(currentWeapon) {					case 1:						if ( numRedOrbs <= 0) {							se.playSound("noAmmoSound");							return;						}						else								numRedOrbs--;						if ( numRedOrbs == 0) {							_gameHUD.minRedBar();							se.playSound("orbBarEmptySound");						}						projectileL = new lm.laserClass();						projectileR = new lm.laserClass();						projectileL.targetX = projectileL.targetY = projectileR.targetX = projectileR.targetY = -1;						variationToPlay = (Math.floor(Math.random() * se.variations("playerLaserSound1")) + 1);						se.playSound("playerLaserSound" + variationToPlay);						break;					case 2:						if ( numGreenOrbs <= 0) {							se.playSound("noAmmoSound");							return;						}						else								numGreenOrbs--;						if (numGreenOrbs == 0) {							_gameHUD.minGreenBar();							se.playSound("orbBarEmptySound");						}						projectileL = new lm.missileClass();						projectileR = new lm.missileClass();						if (crossHairLock) {							var crossHairPoint:Point = _background.globalToLocal(new Point(_crossHair.tempX, _crossHair.tempY));							projectileL.targetX = projectileR.targetX = crossHairPoint.x; 							projectileL.targetY = projectileR.targetY = crossHairPoint.y;						}						else {							projectileL.targetX = projectileL.targetY = projectileR.targetX = projectileR.targetY = -1;						}						variationToPlay = (Math.floor(Math.random() * se.variations("playerMissileSound1")) + 1);						se.playSound("playerMissileSound" + variationToPlay);						break;				}								projectileL.creationTime = projectileR.creationTime = gameClock.currentTime;								projectileL.speed = _playerProjectileSpeed;				projectileL.tempX = _background.globalToLocal(_player.leftGunCoords()).x;				projectileL.tempY = _background.globalToLocal(_player.leftGunCoords()).y;								//projectileL.tempX = _player.leftGunCoords().x;				//projectileL.tempY = _player.leftGunCoords().y;								projectileR.speed = _playerProjectileSpeed;				projectileR.tempX = _background.globalToLocal(_player.rightGunCoords()).x;				projectileR.tempY = _background.globalToLocal(_player.rightGunCoords()).y;				//projectileR.tempX = _player.rightGunCoords().x;				//projectileR.tempY = _player.rightGunCoords().y;								projectileL.angle = projectileR.angle = _player.angle - Math.PI / 2;								_playerProjectileList.push(projectileL);				_playerProjectileList.push(projectileR);								if(playerMovementPlane == 1) {					(_layerList[1] as MovieClip).addChildAt(projectileL as DisplayObject, (_layerList[1] as MovieClip).getChildIndex(_player as DisplayObject));					(_layerList[1] as MovieClip).addChildAt(projectileR as DisplayObject, (_layerList[1] as MovieClip).getChildIndex(_player as DisplayObject));				}				else {					(_layerList[0] as MovieClip).addChildAt(projectileL as DisplayObject, (_layerList[0] as MovieClip).getChildIndex(_player as DisplayObject));					(_layerList[0] as MovieClip).addChildAt(projectileR as DisplayObject, (_layerList[0] as MovieClip).getChildIndex(_player as DisplayObject));				}			}		}				protected function removePlayerProjectile(projectile:DisplayObject):void {			if (projectile.parent == (_layerList[1] as MovieClip)) (_layerList[1] as MovieClip).removeChild(projectile);			else if (projectile.parent == (_layerList[0] as MovieClip)) (_layerList[0] as MovieClip).removeChild(projectile);			_playerProjectileList.splice(_playerProjectileList.indexOf(projectile),1);		}				protected function movePlayerProjectiles():void {			for each (var projectile:IProjectile in _playerProjectileList) {				if(projectile.targetX == -1 && projectile.targetY == -1) {										var xSpeed:Number = Math.cos(projectile.angle) * projectile.speed;					var ySpeed:Number = Math.sin(projectile.angle) * projectile.speed;					projectile.tempX += xSpeed;					projectile.tempY += ySpeed;										/*					//projectile.angle *= (projectile.velocity.length / Laser.maxSpeed);					projectile.acceleration.x += Math.cos(projectile.angle) * Laser.maxAcceleration * gameClock.deltaTime;					projectile.acceleration.y += Math.sin(projectile.angle) * Laser.maxAcceleration * gameClock.deltaTime;					//projectile.velocity.scaleBy(Laser.friction);					projectile.velocity = projectile.velocity.add(projectile.acceleration);					projectile.tempX += projectile.velocity.x * gameClock.deltaTime;					projectile.tempY += projectile.velocity.y * gameClock.deltaTime;					*/				}				else {					projectile.acceleration = new Vector3D();					if ( projectile.directionToTurn == 1){						projectile.angle += (Missile.maxSteering * (projectile.velocity.length / Missile.maxSpeed));					}					else if ( projectile.directionToTurn == -1 ){						projectile.angle -= (Missile.maxSteering * (projectile.velocity.length / Missile.maxSpeed));					}					projectile.acceleration.x += Math.cos(projectile.angle) * Missile.maxAcceleration * gameClock.deltaTime;					projectile.acceleration.y += Math.sin(projectile.angle) * Missile.maxAcceleration * gameClock.deltaTime;					projectile.velocity.scaleBy(Missile.friction);					projectile.velocity = projectile.velocity.add(projectile.acceleration);					projectile.tempX += projectile.velocity.x * gameClock.deltaTime;					projectile.tempY += projectile.velocity.y * gameClock.deltaTime;				}								if (projectile.tempY > _background.r_img.height					|| projectile.tempY < 0					|| projectile.tempX > _background.r_img.width 					|| projectile.tempX  < 0) {					removePlayerProjectile(projectile as DisplayObject);				}									if (projectile is Missile && (gameClock.currentTime-projectile.creationTime)>=projectileLifeTime) {					var explosionSprite = new lm.explosionClass();					explosionSprite.x = projectile.x;					explosionSprite.y = projectile.y;					removePlayerProjectile(projectile as DisplayObject);					(_layerList[1] as MovieClip).addChild(explosionSprite as DisplayObject);					TweenLite.delayedCall(10,(_layerList[1] as MovieClip).removeChild, [explosionSprite], true);				}			}		}				protected function createEnemyProjectile(enemy:IEnemy):void {			if (_gameRunning && (gameClock.currentTime-enemy.lastShotTime)>=(enemyShotDelayTime * Math.random())) {				enemy.lastShotTime = gameClock.currentTime; 				var projectileL:IProjectile;				var projectileR:IProjectile;								switch(enemy.currentWeapon) {					case 1:						projectileL = new lm.laserClass();						projectileR = new lm.laserClass();						break;					case 2:						projectileL = new lm.missileClass();						projectileR = new lm.missileClass();						break;				}				projectileL.speed = _enemyProjectileSpeed;				projectileL.tempX = _background.globalToLocal(enemy.leftGunCoords()).x;				projectileL.tempY = _background.globalToLocal(enemy.leftGunCoords()).y;								projectileR.speed = _enemyProjectileSpeed;				projectileR.tempX = _background.globalToLocal(enemy.rightGunCoords()).x;				projectileR.tempY = _background.globalToLocal(enemy.rightGunCoords()).y;								projectileL.tempRotation = projectileR.tempRotation = enemy.angle - Math.PI/2;				projectileL.rotation = projectileR.rotation = projectileR.tempRotation * (180 / Math.PI);								_enemyProjectileList.push(projectileL);				_enemyProjectileList.push(projectileR);								if(playerMovementPlane == 1) {					(_layerList[1] as MovieClip).addChildAt(projectileL as DisplayObject, (_layerList[1] as MovieClip).getChildIndex(_player as DisplayObject));					(_layerList[1] as MovieClip).addChildAt(projectileR as DisplayObject, (_layerList[1] as MovieClip).getChildIndex(_player as DisplayObject));				}				else {					(_layerList[0] as MovieClip).addChildAt(projectileL as DisplayObject, (_layerList[0] as MovieClip).getChildIndex(_player as DisplayObject));					(_layerList[0] as MovieClip).addChildAt(projectileR as DisplayObject, (_layerList[0] as MovieClip).getChildIndex(_player as DisplayObject));				}								var variationToPlay:int;				if (enemy is Turret) {					variationToPlay = (Math.floor(Math.random() * se.variations("enemyFireSound1")) + 1);					se.playSound("enemyFireSound" + variationToPlay);				}				else {					variationToPlay = (Math.floor(Math.random() * se.variations("enemyLaserSound1")) + 1);					se.playSound("enemyLaserSound" + variationToPlay);				}			}		}				protected function removeEnemyProjectile(projectile:DisplayObject):void {			if (projectile.parent == (_layerList[1] as MovieClip)) (_layerList[1] as MovieClip).removeChild(projectile);			else if (projectile.parent == (_layerList[0] as MovieClip)) (_layerList[0] as MovieClip).removeChild(projectile);			_enemyProjectileList.splice(_enemyProjectileList.indexOf(projectile),1);		}				protected function moveEnemyProjectiles():void {			for each (var projectile:IProjectile in _enemyProjectileList) {				var xSpeed:Number = Math.cos(projectile.tempRotation) * projectile.speed;				var ySpeed:Number = Math.sin(projectile.tempRotation) * projectile.speed;				projectile.tempX += xSpeed;				projectile.tempY += ySpeed;								if (projectile.tempY > _background.r_img.height					|| projectile.tempY < 0					|| projectile.tempX > _background.r_img.width 					|| projectile.tempX  < 0) {					removeEnemyProjectile(projectile as DisplayObject);				}					}		}				protected function removeAllProjectiles():void { 			while (_playerProjectileList.length > 0) {				removePlayerProjectile(_playerProjectileList[0] as DisplayObject);			}			 			while (_enemyProjectileList.length > 0) {				removeEnemyProjectile(_enemyProjectileList[0] as DisplayObject);			}		}				protected function scrollBackground():void {			_background.x_pos += _player.velocity.x / 33; 			_background.y_pos += _player.velocity.y / 33;			if ( _background.x_pos < 0 ){				_background.x_pos = 0;			}			if ( _background.x_pos > (_background.r_img.width - SCREEN_WIDTH) ) {				_background.x_pos = (_background.r_img.width - SCREEN_WIDTH);			}			if ( _background.y_pos < 0 ){				_background.y_pos = 0;			}			if ( _background.y_pos > (_background.r_img.height - SCREEN_HEIGHT) ) {				_background.y_pos = _background.r_img.height - SCREEN_HEIGHT;			}						_background.rect.x = _background.x_pos; 			_background.rect.y = _background.y_pos;			_background.scrollRect = _background.rect;		}						protected function render():void {			if (!_gameRunning) return;						_crossHair.x = _crossHair.tempX;			_crossHair.y = _crossHair.tempY;			_crossHair.rotation = _crossHair.tempRotation;						_player.x = _player.tempX;			_player.y = _player.tempY;			_player.rotation = _player.tempRotation;						var projectile:IProjectile;						for each (projectile in _playerProjectileList) {				projectile.x = projectile.tempX;				projectile.y = projectile.tempY;				projectile.rotation = projectile.tempRotation;			}						for each (projectile in _enemyProjectileList) {				projectile.x = projectile.tempX;				projectile.y = projectile.tempY;			}						for each (var asteroid:IAsteroid in _asteroidList) {				asteroid.x = asteroid.tempX;				asteroid.y = asteroid.tempY;			}						for each (var enemy in _enemyList) {				enemy.rotation = enemy.tempRotation;				if ( enemy is FlyingEnemy ) {					enemy.x = enemy.tempX;					enemy.y = enemy.tempY;				}			}						//_player.update();			/*for each (var enemy:IEnemy in _enemies) {				enemy.x = enemy.tempX;				enemy.y = enemy.tempY;				updateGridReference(enemy);				enemy.update();			}*/					}		//END GAME LOOP LOGIC	}}