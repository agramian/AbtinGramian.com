package com.Engine.Sound {		import flash.events.EventDispatcher;	import flash.media.SoundChannel;	import flash.media.SoundTransform;	import flash.media.Sound;	import flash.media.SoundMixer;		import flash.events.Event;	import flash.events.ProgressEvent;	import flash.events.SecurityErrorEvent;	import flash.net.*;	import flash.system.ApplicationDomain;	import flash.system.LoaderContext;	import flash.utils.getQualifiedClassName;	import flash.events.IOErrorEvent;	import flash.net.URLRequest;	import flash.utils.getDefinitionByName;	import flash.display.Loader;		import com.Engine.events.APEvent;			/**	 *	SoundEngine - Singleton controller for sounds. Allows user to adjust all basic properties of sounds.	 *	 *	@langversion ActionScript 3.0	 *	@playerversion Flash 9.0	 *	 *	@author Christopher Griffith	 *	@since  20.10.2008	 */	public class SoundEngine extends EventDispatcher {				//LIST OF SOUND OBJECTS THAT HAVE ALREADY BEEN CREATED		protected var _soundList:Object;		//FLAG SETTING WHETHER ALL NOT ALL SOUNDS ARE MUTED, SO NEW SOUNDS WILL BE MUTED AS WELL		protected var _allMuted:Boolean = false;				//SINGLETON INSTANCE		static private var _instance:SoundEngine;				protected var _assetDomain:ApplicationDomain;		protected var _assetPath;		protected var _assetQueue;		protected var _assets;		protected var _currentSounds:XML;				//CONSTRUCTOR - NOT ACCESSIBLE MORE THAN ONCE		public function SoundEngine(validator:SoundEngineSingleton) {			if (_instance) throw new Error("SoundEngine is a Singleton class. Use getInstance() to retrieve the existing instance.");			_soundList = new Object();			_assetDomain = new ApplicationDomain(ApplicationDomain.currentDomain);		}				/**		 * Returns the instance of the SoundEngine.		 * @return	SoundEngine		 */		static public function getInstance():SoundEngine {			if (!_instance) _instance = new SoundEngine(new SoundEngineSingleton());			return _instance;		}				/*SOUND MANAGER METHODS*/				public function loadSounds(uri:String):void  {			_assetPath = "";			_assetQueue = new Vector.<String>();			_assets = new Vector.<Loader>();							var request:URLRequest = new URLRequest(uri);			var soundLoader:URLLoader = new URLLoader(request);			soundLoader.addEventListener(Event.COMPLETE, soundLoaded, false, 0, true);			soundLoader.addEventListener(IOErrorEvent.IO_ERROR, soundError, false, 0, true);			soundLoader.addEventListener(SecurityErrorEvent.SECURITY_ERROR, securityError, false, 0, true);		}				public function unloadSounds() {					for each (var seObject:SoundEngineObject in _soundList) {				if(seObject.playing)					seObject.stop();				seObject.removeEventListener(SoundEngineEvent.SOUND_COMPLETE, soundEvent);				seObject.removeEventListener(SoundEngineEvent.SOUND_STOPPED, soundEvent);				seObject.destroySoundEngineObject();			}						_soundList = null;			_soundList = new Object();			for each(var loader:Loader in _assets) {				loader.unload();			}			_assets = null;			_assetQueue = null;		}				protected function soundLoaded(e:Event):void {			_currentSounds = XML(e.target.data);			var assets:XMLList = _currentSounds.assets.children();			for (var i:int = 0; i < assets.length(); i++) {				_assetQueue.push(assets[i].@file);			}			loadNextAsset();		}				protected function soundError(e:IOErrorEvent):void {			trace("SoundEngine Error Message: Failed to load sound: " + e.text);			delete _soundList[e.target.url];			dispatchEvent(new SoundEngineEvent(SoundEngineEvent.SOUND_ERROR, e.target.url));		}			protected function securityError(e:SecurityErrorEvent):void {			trace("SecurityError:",e.text);		}		//END SOUND MANAGEMENT					//ASSET MANAGEMENT		protected function loadNextAsset(e:Event = null):void {			var loader:Loader = new Loader();			var nextAsset:String = _assetQueue[_assets.length];			var context:LoaderContext = new LoaderContext(false, _assetDomain);			loader.load(new URLRequest(_assetPath + nextAsset), context);			loader.contentLoaderInfo.addEventListener(Event.COMPLETE, assetsLoaded, false, 0, true);			loader.contentLoaderInfo.addEventListener(ProgressEvent.PROGRESS, assetLoadProgress, false, 0, true);			loader.contentLoaderInfo.addEventListener(IOErrorEvent.IO_ERROR, assetLoadError, false, 0, true);			loader.contentLoaderInfo.addEventListener(SecurityErrorEvent.SECURITY_ERROR, securityError, false, 0, true);			_assets.push(loader);		}				protected function assetsLoaded(e:Event):void {			if (_assets.length < _assetQueue.length) {				loadNextAsset();				return;			}						createSounds();						dispatchEvent(new APEvent(APEvent.SOUNDS_LOAD_COMPLETE));		}				protected function assetLoadProgress(e:ProgressEvent):void {			var baseCompletion:Number = 100 * (_assets.length-1)/_assetQueue.length;			var currentProgress:Number = (100/_assetQueue.length) * (e.bytesLoaded/e.bytesTotal);			var bytesLoaded:int = Math.round(baseCompletion + currentProgress);			dispatchEvent(new ProgressEvent(ProgressEvent.PROGRESS, false, false, bytesLoaded, 100));		}				protected function assetLoadError(e:IOErrorEvent):void {			trace("SoundEngine: Error Loading Asset: ",_assetQueue[_assets.length-1]);		}				protected function getAssetClass(assetName:String):Class {			if (_assetDomain.hasDefinition(assetName)) {				return _assetDomain.getDefinition(assetName) as Class;			}			throw new ArgumentError("Asset Class "+assetName+" cannot be found in loaded asset files.");		}		//END ASSET MANAGEMENT				//BEGIN SOUND CREATION		protected function createSounds():void {			var assets:XMLList = _currentSounds.assets.children();			var soundClass:Class;			var sound:Sound;			var name:String;			for (var i:int = 0; i < assets.length(); i++) { 				if (assets[i].@variations >0) {					for (var j:int = 1; j <= assets[i].@variations; j++){						soundClass = getAssetClass(assets[i].@soundClass + j);						sound = new soundClass() as Sound;						name = assets[i].@name + j;						var s:SoundEngineObject = new SoundEngineObject(name, sound);						s.variations = assets[i].@variations; 						_soundList[name] = s;						_soundList[name].addEventListener(SoundEngineEvent.SOUND_COMPLETE, soundEvent, false, 0, true);						_soundList[name].addEventListener(SoundEngineEvent.SOUND_STOPPED, soundEvent, false, 0, true);					}				} 				else {					soundClass = getAssetClass(assets[i].@soundClass);					sound = new soundClass() as Sound;					name = assets[i].@name;					_soundList[name] = new SoundEngineObject(name, sound);					_soundList[name].addEventListener(SoundEngineEvent.SOUND_COMPLETE, soundEvent, false, 0, true);					_soundList[name].addEventListener(SoundEngineEvent.SOUND_STOPPED, soundEvent, false, 0, true);				}			}		}		//END SOUND CREATION						protected function soundEvent(e:SoundEngineEvent):void {			dispatchEvent(e);		}						/*SOUND ENGINE METHODS*/				/**		 * Plays the sound specified by the name parameter. Checks for the sound internally first, and then looks for it as an external file.		 * @param	name		String			The name of the linked Sound in the library, or the URL reference to an external sound.		 * @param	offset		Number			The number of seconds offset the sound should start.		 * @param	loops		int				The number of times the sound should loop. Use -1 for infinite looping.		 * @param	transform	transform		The initial sound transform to use for the sound.		 * @return				SoundChannel	The SoundChannel object created by playing the sound. Can also be retrieved through getChannel method.		 */		public function playSound(name:String, offset:Number = 0, loops:int = 0, transform:SoundTransform = null):SoundChannel {			var channel:SoundChannel = _soundList[name].play(offset, loops, transform);			if (_allMuted) mute(name);			return channel;		}				/**		 * Stops the specified sound.		 * @param	name	String	The name of the sound to stop - use the same name used when calling playSound.		 */		public function stopSound(name:String = null):void {			if (name) {				if (_soundList[name]) {					_soundList[name].stop();				} else {					throw new Error("Sound " + name + " does not exist. You must play a sound before you can stop it.");				}			} else {				for (var i:String in _soundList) {					_soundList[i].stop();				}			}		}				/**		 * Sets the volume of a specific sound, or of all sounds in the Engine.		 * @param	value	Number	The value, from 0 to 1, to set the volume.		 * @param	name	String	The name of the sound to change. Pass nothing to modify all sounds in the Engine.		 */		public function setVolume(value:Number, name:String = null):void {			if (name) {				if (_soundList[name]) {					_soundList[name].volume = Math.max(0, Math.min(1, value));				} else {					throw new Error("Sound " + name + " does not exist.");				}			} else {				for (var i:String in _soundList) _soundList[i].volume = Math.max(0, Math.min(1, value));			}		}				/**		 * Returns the volume level of a given sound.		 * @param	name	String	The name of the sound passed into playSound.		 * @return			Number	The value of the volume of the sound.		 */		public function getVolume(name:String):Number {			if (_soundList[name]) {				return _soundList[name].volume;			} else {				throw new Error("Sound " + name + " does not exist.");			}			return null;		}				/**		 * Sets the pan of a specified sound, or of all sounds in the Engine.		 * @param	value	Number	The value, from -1 to 1, to set the pan.		 * @param	name	String	The name of the sound to change. Pass nothing to modify all sounds in the Engine.		 */			public function setPan(value:Number, name:String = null):void {			if (name) {				if (_soundList[name]) {					_soundList[name].pan = value;				} else {					throw new Error("Sound " + name + " does not exist.");				}			} else {				for (var i:String in _soundList) _soundList[i].pan = value;			}		}				/**		 * Returns the pan of a given sound.		 * @param	name	String	The name of the sound passed into playSound.		 * @return			Number	The value of the pan of the sound.		 */		public function getPan(name:String):Number {			if (_soundList[name]) {				return _soundList[name].pan;			} else {				throw new Error("Sound " + name + " does not exist.");			}			return null;		}				/**		 * Sets the transform of a specified sound, or of all sounds in the Engine.		 * @param	transform	SoundChannel	The sound transform to assign.		 * @param	name		String			The name of the sound to change. Pass nothing to modify all sounds in the Engine.		 */		public function setTransform(transform:SoundTransform, name:String = null):void {			if (name) {				if (_soundList[name]) {					_soundList[name].transform = transform;				} else {					throw new Error("Sound " + name + " does not exist.");				}			} else {				for (var i:String in _soundList) _soundList[i].transform = transform;			}		}				/**		 * Returns the transform of a given sound.		 * @param	name	String			The name of the sound passed into playSound.		 * @return			SoundTransform	A copy of the sound transform applied to the named sound.		 */		public function getTransform(name:String):SoundTransform {			if (_soundList[name]) {				return _soundList[name].transform;			} else {				throw new Error("Sound " + name + " does not exist.");			}			return null;		}				/**		 * Returns the active channel of a given sound.		 * @param	name	String			The name of the sound passed into playSound.		 * @return			SoundTransform	A copy of the sound transform applied to the named sound.		 */		public function getChannel(name:String):SoundChannel {			if (_soundList[name]) {				return _soundList[name].channel;			} else {				throw new Error("Sound " + name + " does not exist.");			}			return null;		}				/**		 * Mutes/unmutes the given sound, or all sounds in the Engine.		 * @param	name	String	The name of the sound to mute/unmute. Leave out to act on all sounds in the Engine.		 */		public function mute(name:String = null):void {			if (name) {				if (_soundList[name]) {					_soundList[name].mute();					if (!_soundList[name].muted) _allMuted = false;				} else {					throw new Error("Sound " + name + " does not exist.");				}			} else {				for (var i:String in _soundList) _soundList[i].mute();				_allMuted = !_allMuted;			}		}				/**		 * Pauses/resumes the given sound, or all sounds in the Engine.		 * @param	name	String	The name of the sound to pause or resume. Leave out to act on all sounds in the Engine.		 */		public function pause(name:String = null):void {			if (name) {				if (_soundList[name]) {					_soundList[name].pause();				} else {					throw new Error("Sound " + name + " does not exist.");				}			} else {				for (var i:String in _soundList) _soundList[i].pause();			}		}				/**		 * Returns whether or not a given sound is currently playing.		 * @param	name	String		The name of the sound to check.		 * @return			Boolean		True if playing, false otherwise. If a sound is only paused, it will still return as playing.		 */		public function isPlaying(name:String):Boolean {			if (_soundList[name]) {				return _soundList[name].playing;			} else throw new Error("Sound " + name + " does not exist.");			return false;		}				/**		 * Returns whether or not a given sound is currently paused.		 * @param	name	String		The name of the sound to check.		 * @return			Boolean		True if sound is paused, false otherwise.		 */		public function isPaused(name:String):Boolean {			if (_soundList[name]) {				return _soundList[name].paused;			} else throw new Error("Sound " + name + " does not exist.");			return false;		}				/**		 * Returns whether or not a given sound is muted.		 * @param	name	String		The name of the sound to check.		 * @return			Boolean		True if muted, false otherwise.		 */		public function isMuted(name:String):Boolean {			if (_soundList[name]) {				return _soundList[name].muted;			} else throw new Error("Sound " + name + " does not exist.");			return false;		}				public function variations(name:String):int {			if (_soundList[name]) {				return _soundList[name].variations;			} else throw new Error("Sound " + name + " does not exist.");			return false;		}			}	}import flash.events.Event;import flash.events.EventDispatcher;import flash.media.Sound;import flash.media.SoundChannel;import flash.media.SoundTransform;import com.Engine.Sound.SoundEngineEvent;class SoundEngineObject extends EventDispatcher {		public var name:String;	public var sound:Sound;	public var channel:SoundChannel;	public var variations:int;		protected var _transform:SoundTransform;	protected var _playing:Boolean = false;	protected var _muted:Boolean = false;	protected var _paused:Boolean = false;	protected var _pauseTime:Number;	protected var _loops:int;	protected var _offset:Number;		public function SoundEngineObject(name:String, sound:Sound) {		this.name = name;		this.sound = sound;	}		public function destroySoundEngineObject() {		this.name = null;		this.sound = null;		this.channel = null;	}		public function play(offset:Number = 0, loops:int = 0, transform:SoundTransform = null):SoundChannel {		_offset = offset;		channel = sound.play(_offset, 0, transform);		channel.addEventListener(Event.SOUND_COMPLETE, complete, false, 0, true);		_transform = channel.soundTransform;		_loops = loops;		_playing = true;		return channel;	}		public function stop():void {		channel.stop();		_loops = 0;		_playing = false;		dispatchEvent(new SoundEngineEvent(SoundEngineEvent.SOUND_STOPPED, name));	}		protected function complete(e:Event):void {		if (_loops != 0) {			play(_offset, _loops--, _transform);		} else {			_playing = false;		}		dispatchEvent(new SoundEngineEvent(SoundEngineEvent.SOUND_COMPLETE, name));	}		public function get playing():Boolean {		return _playing;	}		public function get volume():Number {		return channel.soundTransform.volume;	}		public function set volume(value:Number):void {		var tf:SoundTransform = _transform;		tf.volume = value;		_transform = tf;		if (!_muted) channel.soundTransform = _transform;	}		public function get pan():Number {		return channel.soundTransform.pan;	}		public function set pan(value:Number):void {		var tf:SoundTransform = _transform;		tf.pan = value;		_transform = tf;		if (!_muted) channel.soundTransform = _transform;	}		public function get transform():SoundTransform {		return new SoundTransform(transform.volume, transform.pan);	}		public function set transform(tr:SoundTransform):void {		_transform = tr;		if (!_muted) channel.soundTransform = _transform;	}		public function mute():void {		if (_muted) {			channel.soundTransform = _transform;		} else {			channel.soundTransform = new SoundTransform(0, 0);		}		_muted = !_muted;	}		public function get muted():Boolean {		return _muted;	}		public function pause():void {		if (_paused) {			var normalOffset:Number = _offset;			play(_pauseTime, _loops, _transform);			_offset = normalOffset;		} else {			_pauseTime = channel.position;			channel.stop();		}		_paused = !_paused;	}			public function get paused():Boolean {		return _paused;	}	}class SoundEngineSingleton {}