package AbtinPat {	import com.Engine.Sprites.IEnemy;		import flash.display.DisplayObject;	import flash.display.Sprite;	import flash.display.MovieClip;	import flash.geom.Point;	import flash.geom.Vector3D;			public class FlyingEnemy extends Sprite implements IEnemy {				private var _tempX:Number = 0;		private var _tempY:Number = 0;		private var _tempRotation:Number = 0;		private var _lastShotTime:int = 0;				static public const maxSpeed:Number = 150;		static public const maxAcceleration:Number = 100;		static public const minAcceleration:Number = 30;		static public const maxSteering:Number = Math.PI / 30; // RADIANS PER SECOND;		static public const stoppingThreshold:Number = 0.1; //THRESHOLD FOR ROUNDING DOWN TO 0		static public const friction:Number = .95; //COEFFICIENT OF FRICTION OF THE "ROAD"		private var _velocity:Vector3D = new Vector3D();		private var _acceleration:Vector3D = new Vector3D();		protected var _angle:Number = 0; //ANGLE IN RADIANS				private var leftGun:DisplayObject;		private var rightGun:DisplayObject;		private var healthBar:DisplayObject;				private var _currentWeapon:int = 1;		private var _health:int = 100;		private var _playerSpotted:Boolean = false;				public function FlyingEnemy():void {			leftGun = getChildByName("leftGun");			rightGun = getChildByName("rightGun");			healthBar = getChildByName("healthBar");		}				public function get lastShotTime():int {			return _lastShotTime;		}				public function set lastShotTime(value:int):void {			_lastShotTime = value;		}				public function get tempX():Number {			return _tempX;		}				public function set tempX(value:Number):void {			_tempX = value;		}				public function get tempY():Number {			return _tempY;		}				public function set tempY(value:Number):void {			_tempY = value;		}				public function get tempRotation():Number {			return _tempRotation;		}				public function set tempRotation(value:Number):void {			_tempRotation = value;		}				public function get angle():Number {			return _angle;		}				public function set angle(value:Number):void {			_angle = value;			_angle %= 2*Math.PI;			_tempRotation = _angle * (180 / Math.PI);		}				public function get frontVector():Vector3D {			return new Vector3D(Math.cos(angle-Math.PI/2),Math.sin(angle-Math.PI/2));		}				public function directionToTurn(playerPoint:Point, turretPoint:Point):int {			var tempVector:Vector3D = new Vector3D(playerPoint.x-turretPoint.x, playerPoint.y-turretPoint.y);			var tempVLength:Number = tempVector.length;			tempVector.x /= tempVLength;			tempVector.y /= tempVLength;			if (tempVector.dotProduct(this.frontVector) > .99 ) {				return 0;			}						if ( tempVector.crossProduct(this.frontVector).z > 0 ) {				return 1;			}			else {				return -1;			}			return 0;		}				public function leftGunCoords():Point {			return localToGlobal(new Point(leftGun.x, leftGun.y));		}				public function rightGunCoords():Point {			return localToGlobal(new Point(rightGun.x, rightGun.y));		}				public function set currentWeapon(value:int):void {			_currentWeapon = value;		}				public function get currentWeapon():int {			return _currentWeapon;		}				public function get health():int {			return _health;		}				public function set health(value:int):void {				_health = value;				healthBar.scaleX = _health/100;		}				public function get velocity():Vector3D {			return _velocity;		}				public function set velocity(value:Vector3D):void {			_velocity = value;			if (_velocity.length > maxSpeed) {				var overage:Number = (_velocity.length - maxSpeed) / maxSpeed;				_velocity.scaleBy(1 / (1 + overage));			}			if (_velocity.length < stoppingThreshold) {				_velocity.x = _velocity.y = 0;			}		}				public function get acceleration():Vector3D {			return _acceleration;		}				public function set acceleration(value:Vector3D):void {			_acceleration = value;		}				public function get playerSpotted():Boolean {			return _playerSpotted;		}				public function set playerSpotted(value:Boolean):void {			_playerSpotted = value;		}				override public function get hitArea():Sprite {			return this;		}			}	}